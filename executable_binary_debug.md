
##  󰟷



$0x404713이라는 것은 저 주소에 어떤 상수값이 있다는것같은데, 그걸 %rax에 넣겠다는거 아냐? 근데 program header에선 저 주소가 포함된 구간은 안보이는것같아. 어떻게 된거야? 



```asm
 809 │ 0000000000400bae <_start>:
 810 │   400bae:   f3 0f 1e fa             endbr64
 811 │   400bb2:   55                      push   %rbp
 812 │   400bb3:   48 89 e5                mov    %rsp,%rbp
 813 │   400bb6:   48 83 ec 10             sub    $0x10,%rsp
 814 │   400bba:   89 7d fc                mov    %edi,-0x4(%rbp)
 815 │   400bbd:   48 89 75 f0             mov    %rsi,-0x10(%rbp)
 816 │   400bc1:   48 b8 13 47 40 00 00    movabs $0x404713,%rax
 817 │   400bc8:   00 00 00
```

```asm
userprog$ objdump -p create-normal | bat -l asm
─────┬──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
     │ STDIN
─────┼──────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────────
   1 │
   2 │ create-normal:     file format elf64-x86-64
   3 │
   4 │ Program Header:
   5 │     LOAD off    0x0000000000000000 vaddr 0x00000000003ff000 paddr 0x00000000003ff000 align 2**12
   6 │          filesz 0x0000000000000190 memsz 0x0000000000000190 flags r--
   7 │     LOAD off    0x0000000000001000 vaddr 0x0000000000400000 paddr 0x0000000000400000 align 2**12
   8 │          filesz 0x0000000000004e60 memsz 0x0000000000004e60 flags r-x
   9 │     LOAD off    0x0000000000000e60 vaddr 0x0000000000405e60 paddr 0x0000000000405e60 align 2**12
  10 │          filesz 0x0000000000000000 memsz 0x0000000000000524 flags rw-
  11 │     NOTE off    0x0000000000005e40 vaddr 0x0000000000404e40 paddr 0x0000000000404e40 align 2**3
  12 │          filesz 0x0000000000000020 memsz 0x0000000000000020 flags r--
  13 │ 0x6474e553 off    0x0000000000005e40 vaddr 0x0000000000404e40 paddr 0x0000000000404e40 align 2**3
  14 │          filesz 0x0000000000000020 memsz 0x0000000000000020 flags r--
  15 │    STACK off    0x0000000000000000 vaddr 0x0000000000000000 paddr 0x0000000000000000 align 2**4
  16 │          filesz 0x0000000000000000 memsz 0x0000000000000000 flags rw-
```

##  󱞩   _Copilot
네, 좋은 질문입니다. 혼동하기 쉬운 부분입니다.

결론부터 말씀드리면, `movabs $0x404713, %rax` 명령어는 메모리 주소 `0x404713`에 있는 *값*을 `%rax`에 넣는 것이 아니라, `0x404713`이라는 *주소 자체*를 `%rax` 레지스터에 넣는 명령어입니다.

AT&T 문법에서 `$` 기호는 '즉시값(immediate value)'을 의미합니다. 즉, 상수 값을 직접 사용하겠다는 뜻입니다.

만약 `0x404713` 주소에 있는 내용을 가져오고 싶었다면, 명령어는 `mov 0x404713, %rax`와 같이 `$` 없이 사용되었을 것입니다.

또한, 제공해주신 Program Header를 보면 `0x404713` 주소는 두 번째 `LOAD` 세그먼트에 포함됩니다.

*   **두 번째 `LOAD` 세그먼트:**
    *   가상 주소(vaddr): `0x400000`
    *   메모리 크기(memsz): `0x4e60`
    *   범위: `0x400000` ~ `0x400000 + 0x4e60` (즉, `0x404e60`)

`0x404713`은 이 범위 안에 있으므로 유효한 주소입니다. 컴파일러는 종종 문자열 리터럴이나 다른 상수 데이터를 코드와 가까운 읽기 전용 데이터 섹션(`.rodata`)에 배치합니다. 이 명령어는 아마도 그 데이터의 주소를 `%rax` 레지스터에 로드하여 이후에 사용하려는 것으로 보입니다.

다음에 `objdump -s`나 GDB를 사용하여 `0x404713` 주소에 어떤 데이터가 있는지 확인해 보시는 것은 어떨까요?

##  󰟷

잠깐, 그전에 off의 경우 세그먼트를 모두 로딩한 뒤에 얼만큼 0으로 채우는지 알려주는 값이야? 그리고 paddr랑 align도 설명해줘. 

##  󱞩   _Copilot
네, 물론입니다. ELF 프로그램 헤더의 각 필드에 대해 설명해 드리겠습니다.

사용자께서 생각하신 "세그먼트를 로딩한 뒤 0으로 채우는 부분"은 `off`가 아니라, `filesz`와 `memsz`의 차이와 관련이 있습니다.

### `off` (Offset)
이것은 세그먼트의 내용이 ELF 파일의 **시작 지점으로부터 얼마나 떨어져 있는지**를 나타내는 오프셋입니다. 즉, 파일 내에서의 위치를 의미합니다.

예를 들어, 두 번째 `LOAD` 세그먼트의 `off`는 `0x1000`입니다. 이는 운영체제 로더가 이 세그먼트를 메모리에 올리기 위해 `create-normal` 파일의 `0x1000` 바이트 위치부터 `filesz` 만큼의 데이터를 읽어야 한다는 뜻입니다.

### `paddr` (Physical Address)
이 필드는 세그먼트가 로드될 **물리 메모리 주소**를 의미합니다.

하지만 리눅스와 같은 현대적인 운영체제에서는 가상 메모리 시스템을 사용하기 때문에 이 `paddr` 필드는 대부분의 경우 무시됩니다. 커널이 가상 주소(`vaddr`)를 실제 물리 메모리 주소로 매핑하는 작업을 알아서 처리하기 때문입니다. 이 필드는 주로 MMU(메모리 관리 장치)가 없는 임베디드 시스템이나 특수한 환경에서 의미를 가집니다.

### `align` (Alignment)
이것은 세그먼트가 메모리에 로드될 때 주소가 지켜야 할 **정렬(alignment) 요구사항**입니다. 값은 2의 거듭제곱으로 표현됩니다 (`2**12`는 4096, 즉 4KB).

메모리 정렬은 성능 최적화와 하드웨어 요구사항 때문에 중요합니다. 예를 들어, `align 2**12` (4096)는 세그먼트의 시작 가상 주소(`vaddr`)가 4096의 배수여야 함을 의미합니다. 이는 현대 CPU의 메모리 페이징 단위(보통 4KB)와 일치시키기 위함입니다.

---

### 요약 및 예시 (세 번째 `LOAD` 세그먼트)

```
LOAD off 0x0e60 vaddr 0x405e60 ... filesz 0x0 memsz 0x524 flags rw-
```

*   **`off 0x0e60`**: 이 세그먼트에 대한 정보는 파일의 `0x0e60` 위치에서 시작됩니다.
*   **`filesz 0x0`**: 하지만 파일에서 읽어올 데이터의 크기는 0바이트입니다. 이는 보통 초기화되지 않은 전역 변수들이 모여있는 `.bss` 섹션에 해당합니다.
*   **`vaddr 0x405e60`**: 이 세그먼트는 가상 메모리의 `0x405e60` 주소에 위치합니다.
*   **`memsz 0x524`**: 메모리에는 `0x524` 바이트만큼의 공간을 할당합니다.
*   **결론**: 로더는 파일에서 데이터를 읽지 않고(`filesz`가 0이므로), 메모리의 `0x405e60` 주소부터 `0x524` 바이트만큼의 공간을 확보한 뒤 그 공간을 모두 0으로 채웁니다. 이것이 바로 사용자께서 생각하신 "0으로 채우는" 동작입니다.

이제 프로그램 헤더의 의미가 더 명확해지셨나요? 다음으로 이전에 제안했던 `objdump -s` 명령을 실행하여 `0x404713` 주소의 내용을 확인해 보시겠어요?

##  󰟷

실행파일(바이너리 코드)를 직접 수정하고싶어.

두번째 call이 실행되는걸 보고싶은데 아직 첫번째 call에 해당하는 기능을 만들지 못했거든? 그래서 400024 주소만 잠시 지워버리면 될것같은데 어떻게 생각해? 


```asm
   7 │ 0000000000400000 <test_main>:
   8 │   400000:   f3 0f 1e fa             endbr64
   9 │   400004:   55                      push   %rbp
  10 │   400005:   48 89 e5                mov    %rsp,%rbp
  11 │   400008:   48 b8 e0 44 40 00 00    movabs $0x4044e0,%rax
  12 │   40000f:   00 00 00
  13 │   400012:   48 89 c7                mov    %rax,%rdi
  14 │   400015:   b8 00 00 00 00          mov    $0x0,%eax
  15 │   40001a:   48 ba 59 02 40 00 00    movabs $0x400259,%rdx
  16 │   400021:   00 00 00
  17 │   400024:   ff d2                   call   *%rdx
  18 │   400026:   be 00 00 00 00          mov    $0x0,%esi
  19 │   40002b:   48 b8 f0 44 40 00 00    movabs $0x4044f0,%rax
  20 │   400032:   00 00 00
  21 │   400035:   48 89 c7                mov    %rax,%rdi
  22 │   400038:   48 b8 a1 35 40 00 00    movabs $0x4035a1,%rax
  23 │   40003f:   00 00 00
  24 │   400042:   ff d0                   call   *%rax
  25 │   400044:   83 f0 01                xor    $0x1,%eax
```

##  󱞩   _Copilot
네, 좋은 생각입니다. 첫 번째 `call`을 건너뛰고 두 번째 `call`의 동작을 먼저 테스트하는 것은 디버깅에 매우 유용한 방법입니다.

하지만 말씀하신 것처럼 주소 `0x400024`의 명령어를 "지워버리는" 것은 위험합니다. 실행 파일에서 바이트를 삭제하면 그 뒤에 있는 모든 코드와 데이터의 주소가 밀리게 되어 파일 전체의 구조가 깨지고 실행이 불가능해집니다.

더 안전하고 일반적인 방법은 해당 명령어를 아무 동작도 하지 않는 `NOP` (No-Operation) 명령어로 덮어쓰는(patching) 것입니다.

`0x400024` 주소의 `call *%rdx` 명령어(`ff d2`)는 2바이트 크기입니다. 따라서 2개의 `NOP` 명령어로 바꾸면 됩니다. `NOP`의 16진수 코드는 `0x90`입니다.

### 계획
1.  `call *%rdx` 명령어의 파일 내 위치(offset)를 계산합니다.
2.  해당 위치의 2바이트를 `0x9090`으로 덮어씁니다.

### 파일 오프셋 계산
`objdump -p` 결과에서 `vaddr` `0x400000`은 파일 오프셋 `0x1000`에 해당합니다.
따라서 `0x400024`의 파일 오프셋은 `0x1000 + (0x400024 - 0x400000) = 0x1024` 입니다.

### 바이너리 패치 명령어
아래 명령어를 터미널에서 실행하여 실행 파일을 직접 수정할 수 있습니다. **수정하기 전에 원본 파일을 백업하는 것을 강력히 권장합니다.**

```bash
# 원본 파일 백업
cp your_executable your_executable.bak

# 0x1024 오프셋에 2바이트 NOP(0x9090) 쓰기
printf '\x90\x90' | dd of=your_executable bs=1 seek=$((0x1024)) count=2 conv=notrunc
```
*(위 명령어에서 `your_executable`을 실제 파일 이름으로 바꿔주세요.)*

이 명령을 실행한 후 `objdump -d your_executable`로 다시 확인하면 `0x400024` 주소의 명령어가 `nop; nop;`으로 바뀐 것을 볼 수 있습니다. 이렇게 하면 첫 번째 `call`을 안전하게 건너뛸 수 있습니다.

이 방법으로 바이너리를 수정해 보시겠어요? 수정 후 결과를 확인하는 데 도움이 필요하면 알려주세요.

##  󰟷

뭐지? 황당하네, sudo가 안돼?

```sh
userprog$ sudo printf '\x90\x90' | dd of=create-normal bs=1 seek=$((0x1024)) count=2 conv=notrunc
dd: failed to open 'create-normal': Permission denied
```

##  󱞩   _Copilot
`sudo`가 파이프(`|`)와 함께 사용될 때 흔히 발생하는 문제입니다.

사용하신 명령어 `sudo printf ... | dd ...`에서 `sudo`는 `printf` 명령어에만 적용됩니다. 파이프를 통해 전달된 결과를 받는 `dd` 명령어는 여전히 일반 사용자 권한으로 실행되기 때문에 'Permission denied' 오류가 발생한 것입니다.

이 문제를 해결하려면, 파일에 직접 쓰는 권한이 필요한 `dd` 명령어에 `sudo`를 적용해야 합니다.

### 해결 방법 1: `dd`에 직접 `sudo` 사용
`printf`의 결과를 파이프로 `sudo dd`에 전달합니다.

````bash
printf '\x90\x90' | sudo dd of=create-normal bs=1 seek=$((0x1024)) count=2 conv=notrunc
````

### 해결 방법 2: 전체 명령어를 `sudo`로 실행
`sudo`가 전체 파이프라인에 영향을 미치도록 셸을 이용해 감싸줍니다.

````bash
sudo sh -c "printf '\x90\x90' | dd of=create-normal bs=1 seek=$((0x1024)) count=2 conv=notrunc"
````

두 방법 모두 동일하게 동작합니다. 첫 번째 방법이 더 간결하고 일반적입니다.

이 명령어로 다시 시도해 보시겠어요? 성공적으로 실행된 후 `objdump`로 변경 사항을 확인해 보세요.

##  󰟷



## 바이너리코드 수정 및 테스트 결과


> [!lg] Log 2025-11-27
>
> 와 이게 되네.. 신기허네..


- 변경 전
  ```asm
  
  create-normal:     file format elf64-x86-64
  
  
  Disassembly of section .text:
  
  0000000000400000 <test_main>:
    400000:	f3 0f 1e fa          	endbr64
    400004:	55                   	push   %rbp
    400005:	48 89 e5             	mov    %rsp,%rbp
    400008:	48 b8 e0 44 40 00 00 	movabs $0x4044e0,%rax
    40000f:	00 00 00 
    400012:	48 89 c7             	mov    %rax,%rdi
    400015:	b8 00 00 00 00       	mov    $0x0,%eax
    40001a:	48 ba 59 02 40 00 00 	movabs $0x400259,%rdx
    400021:	00 00 00 
    400024:	ff d2                	call   *%rdx
    400026:	be 00 00 00 00       	mov    $0x0,%esi
    40002b:	48 b8 f0 44 40 00 00 	movabs $0x4044f0,%rax
    400032:	00 00 00 
    400035:	48 89 c7             	mov    %rax,%rdi
    400038:	48 b8 a1 35 40 00 00 	movabs $0x4035a1,%rax
    40003f:	00 00 00 
    400042:	ff d0                	call   *%rax
    400044:	83 f0 01             	xor    $0x1,%eax
    400047:	84 c0                	test   %al,%al
    400049:	74 1e                	je     400069 <test_main+0x69>
    40004b:	48 b8 e0 44 40 00 00 	movabs $0x4044e0,%rax
    400052:	00 00 00 
    400055:	48 89 c7             	mov    %rax,%rdi
    400058:	b8 00 00 00 00       	mov    $0x0,%eax
    40005d:	48 ba ce 02 40 00 00 	movabs $0x4002ce,%rdx
    400064:	00 00 00 
    400067:	ff d2                	call   *%rdx
    400069:	90                   	nop
    40006a:	5d                   	pop    %rbp
    40006b:	c3                   	ret
  
  ```

- 변경 후
  ```asm
  
  create-normal:     file format elf64-x86-64
  
  
  Disassembly of section .text:
  
  0000000000400000 <test_main>:
    400000:	f3 0f 1e fa          	endbr64
    400004:	55                   	push   %rbp
    400005:	48 89 e5             	mov    %rsp,%rbp
    400008:	48 b8 e0 44 40 00 00 	movabs $0x4044e0,%rax
    40000f:	00 00 00 
    400012:	48 89 c7             	mov    %rax,%rdi
    400015:	b8 00 00 00 00       	mov    $0x0,%eax
    40001a:	48 ba 59 02 40 00 00 	movabs $0x400259,%rdx
    400021:	00 00 00 
    400024:	90                   	nop
    400025:	90                   	nop
    400026:	be 00 00 00 00       	mov    $0x0,%esi
    40002b:	48 b8 f0 44 40 00 00 	movabs $0x4044f0,%rax
    400032:	00 00 00 
    400035:	48 89 c7             	mov    %rax,%rdi
    400038:	48 b8 a1 35 40 00 00 	movabs $0x4035a1,%rax
    40003f:	00 00 00 
    400042:	ff d0                	call   *%rax
    400044:	83 f0 01             	xor    $0x1,%eax
    400047:	84 c0                	test   %al,%al
    400049:	74 1e                	je     400069 <test_main+0x69>
    40004b:	48 b8 e0 44 40 00 00 	movabs $0x4044e0,%rax
    400052:	00 00 00 
    400055:	48 89 c7             	mov    %rax,%rdi
    400058:	b8 00 00 00 00       	mov    $0x0,%eax
    40005d:	48 ba ce 02 40 00 00 	movabs $0x4002ce,%rdx
    400064:	00 00 00 
    400067:	ff d2                	call   *%rdx
    400069:	90                   	nop
    40006a:	5d                   	pop    %rbp
    40006b:	c3                   	ret
  
  ```
