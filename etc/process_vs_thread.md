
## 1. 기본 개념: 기계와 코어의 추상화

- **프로세스 (Process)**: **"독립된 컴퓨터"**의 추상화.
- 운영체제로부터 자신만의 독립적인 자원(특히, 가상 주소 공간)을 할당받는 실행 단위.
- 프로세스 간 메모리 공간은 완벽히 분리되어 서로 직접 접근할 수 없음 (IPC 필요).

- **스레드 (Thread)**: **"CPU 코어"**의 추상화.
- 프로세스 내에서 실행 흐름을 구성하는 가장 작은 단위.
- 자신이 속한 프로세스의 자원(특히, 메모리 공간)을 공유함.
- 독립적인 실행 흐름을 위해 스택과 레지스터 세트는 개별적으로 가짐.

## 2. 스레드의 메모리 구조: 공유와 독립의 공존

스레드는 가상 주소 공간을 "공유"하지만, 그 안의 모든 것을 똑같이 사용하는 것은 아닙니다.

### 2.1. 스택 (Stack): 독립적인 실행의 기반

스택은 각 스레드가 자신만의 독립적인 실행 흐름을 유지할 수 있게 하는 핵심 요소입니다.

- **특징**:
- **스레드별 독립**: 각 스레드는 자신만의 고유한 스택 영역을 가집니다.
- **역할**: 함수 호출 시 매개변수, 지역 변수, 복귀 주소 등을 저장합니다.
- **종류**: 사용자 모드에서 사용하는 **사용자 스택(User Stack)**과 커널 모드에서 사용하는 **커널 스택(Kernel Stack)** 모두 스레드별로 독립적으로 존재합니다.

- **구현 원리**:
1. **할당**: 메인 스레드 외에 새로운 스레드가 생성될 때, OS는 `mmap`과 같은 시스템 콜을 사용하여 프로세스의 가상 주소 공간 내 비어있는 영역에 스택 메모리를 "띄엄띄엄" 할당합니다. 이 영역들은 서로 겹치지 않습니다.
2. **관리**: 현재 실행 중인 스레드의 스택 포인터(`rsp`)는 CPU가 직접 관리합니다. 컨텍스트 스위칭이 발생하면, 커널은 현재 스레드의 `rsp`를 포함한 모든 레지스터 값을 해당 스레드의 TCB(Thread Control Block, 리눅스에서는 `task_struct`)에 저장하고, 새로 실행할 스레드의 TCB에서 레지스터 값들을 복원합니다.
3. access) 속성의 메모리 페이지를 배치합니다. 스택이 이 영역을 침범하면 하드웨어 예외가 발생하고, OS는 프로세스에 `SIGSEGV` 시그널을 보내 강제 종료시킵니다.

### 2.2. 힙 (Heap): 완스택 오버플로우 (Stack Overflow)**:

- 스택은 동적으로 확장되지 않습니다. 할당된 크기를 넘어서면 프로그램은 비정상 종료됩니다.
- **가드 페이지(Guard Page)**: OS는 스택 영역 바로 다음에 접근 금지(no-**크기 제어**: 스레드 생성 시 `pthread_attr_setstacksize`와 같은 함수를 통해 프로그래머가 스택의 크기를 명시적으로 지정할 수 있습니다. (예: 깊은 재귀 호출을 위해 크게, 수많은 스레드를 위해 작게).

- 완벽하게 공유되는 자원

힙은 스레드 간 데이터 공유의 핵심 통로이자, 동시성 문제의 주된 원인이 됩니다.

- **특징**:
- **프로세스 내 모든 스레드가 공유**: 한 스레드가 `malloc`이나 `new`로 할당한 메모리는 다른 모든 스레드에서 동일한 주소로 접근 가능합니다.
- **독립성 없음**: 하드웨어(MMU)나 OS 커널은 힙 영역에 접근하는 주체가 어떤 스레드인지 구분하지 않습니다.

- **공유 원리**:
- 프로세스 내 모든 스레드의 TCB(`task_struct`)는 **단 하나의 메모리 관리 구조체(`mm_struct`)**를 가리킵니다.
- 가상 주소를 물리 주소로 변환하는 데 사용되는 페이지 테이블(PML4)의 주소는 이 공유된 `mm_struct` 안에 저장됩니다.
- 따라서 어떤 스레드가 CPU를 점유하든, 항상 동일한 페이지 테이블을 사용하게 되므로 동일한 메모리 매핑을 보게 됩니다. PTE(Page Table Entry)에는 스레드 ID와 같은 정보가 없습니다.

- **결과: 동기화의 필요성**:
- 여러 스레드가 힙에 있는 동일한 데이터를 동시에 수정하려 할 때 **경쟁 상태(Race Condition)**가 발생하여 데이터가 손상될 수 있습니다.
- 이를 방지하기 위해 프로그래머는 **뮤텍스(Mutex), 세마포어(Semaphore), 스핀락(Spinlock)** 등의 동기화 기법을 사용하여 공유 자원에 대한 접근을 한 번에 하나의 스레드로 제한해야 합니다.

### 2.3. (보충) 스레드 로컬 스토리지 (Thread Local Storage, TLS)

스택처럼 스레드별로 독립적이면서, 전역 변수처럼 프로그램의 어느 함수에서든 접근할 수 있는 데이터가 필요할 때 사용합니다.

- **개념**: 각 스레드가 자신만의 독립적인 저장 공간을 갖는 전역/정적 변수입니다.
- **예시**: C/C++에서 `__thread` 또는 `thread_local` 키워드를 사용하여 선언합니다.
`thread_local int my_global_var = 0;`
- **동작**: 스레드 A가 `my_global_var`를 10으로 바꿔도, 스레드 B의 `my_global_var`는 여전히 0입니다.
- **구현**: 컴파일러와 OS가 협력하여, TCB 근처에 각 스레드별 TLS 데이터 영역을 할당하고, 특별한 세그먼트 레지스터(`fs` 또는 `gs`)를 통해 빠르게 접근할 수 있도록 구현됩니다.

## 3. 최종 요약 테이블

| 구분 | 스택 (Stack) | 힙 (Heap) | 데이터/코드 | TLS |
| :--- | :--- | :--- | :--- | :--- |
| **소유권** | 스레드 개별 소유 | 프로세스 공유 | 프로세스 공유 | 스레드 개별 소유 |
| **생명 주기** | 함수/블록 진입 시 생성, 탈출 시 소멸 | 프로그래머가 명시적으로 할당/해제 | 프로세스 시작부터 끝까지 | 스레드 시작부터 끝까지 |
| **동기화** | 필요 없음 (원천적으로 독립) | **필수** (경쟁 상태 발생 가능) | 보통 읽기 전용이라 불필요 | 필요 없음 |
| **크기** | 고정 크기 (생성 시 결정) | 동적 크기 (가변적) | 고정 크기 | 고정 크기 |
