## QnA


### 운영체제는 커널 프로세스를 생성해 작업하는가?

커널은 프로세스로 추상화되어 동작하지 않는다. (프로세스는 독립적인 가상주소공간을 가지지만 커널은 그런식으로 동작하지 않는다.) 프로세스가 아니기 때문에 scheduling 되지도 않는다.

그보다는 운영체제는 커널 쓰레드를 다수 생성해 필요한 작업을 수행한다. 이 쓰레드는 스케쥴러에 의해 관리된다.


커널 쓰레드는 커널 코드, 메모리 영역, 하드웨어 등 모든 커널영역에 접근할 수 있다.

커널 쓰레드는 항상 커널모드로 동작한다.




### 유저 프로세스가 system call을 호출하면 커널 쓰레드로 컨텍스트 스위칭이 발생하는건가?

아니다. 그냥 호출한 유저 프로세스의 쓰레드가 "커널모드"로 잠시 전환되어 실행된다.




### 커널 쓰레드는 모든 자식프로세스(유저프로그램 등)의 부모 쓰레드가 되는건가?


아니다. 커널 쓰레드가 systemd(과거에는 init)라는 유저프로그램을 부팅이 완료되면 바로 시작해주고, 이것이 모든 다른 유저프로세스의 부모 프로세스가 된다.
만약 어떤 프로세스가 좀비 프로세스가 되더라도, 그것의 부모 프로세스는 적어도 systemd가 된다.

- 이것은 일반적인 실행 파일(ELF 바이너리)로 `/usr/lib/systemd/systemd`에 위치한다.
- 이것은 유저 프로그램이기 때문에 유저 공간에서 실행된다.


핀토스의 경우 커널 쓰레드가 직접 유저쓰레드를 실행시켜준다.


### exec하고나면 부모자식 관계는 사라지는건가? 즉, 동일한 process group이 아니게 되는건가? 

아니다. 여전히 동일한 process group에 속한다.



### palloc() vs malloc()

- `palloc()`

    - **palloc**은 커널 내부에서 페이지(4KB 단위)를 할당하는 함수입니다.
    - **커널 쓰레드**나 **커널 코드**에서만 호출할 수 있습니다.
    - **사용자 프로그램; 유저 프로세스**에서는 직접 호출할 수 **없습니다.**  

      사용자 프로그램은 동적 메모리할당 필요시 malloc이라는 표준함수를 사용하는데,
      이것의 내부 구현에 systemcall을 통해 kernel이 필요시 palloc을 사용토록 한다.



- `malloc()`

    - **malloc은 사용자 공간(유저 프로그램)에서만 동작**하도록 설계되어 있습니다.
    - 커널은 자체적인 메모리 할당자(예: palloc, kmalloc 등)를 사용합니다.
    - 커널 코드에는 표준 C 라이브러리(예: libc)가 포함되지 않으므로, malloc을 "쓸 수 없다"고 보는 것이 맞습니다.



### OS의 작동은 모두 kernel 쓰레드를 통해 이루어지는거야?


- OS의 주요 작동(시스템 관리, 자원 관리, 서비스 제공 등)은 **대부분 커널 쓰레드를 통해** 이루어집니다.

    - 예: 스케줄러, 디스크 관리, 네트워크 처리, 백그라운드 작업 등
    - 커널 쓰레드는 커널 공간에서 동작하며, 시스템 자원에 직접 접근할 수 있습니다.



- **예외**

    - 일부 커널 코드(인터럽트 핸들러 등)는 커널 쓰레드가 아닌, CPU의 인터럽트 컨텍스트에서 직접 실행될 수 있습니다.
    - 시스템 콜 처리 시에는 유저 쓰레드가 커널 모드로 전환되어 커널 코드를 실행합니다(별도의 커널 쓰레드가 아님).


### 커널 쓰레드도 가상주소공간을 사용하나?


- 현대 OS

    - 커널 쓰레드 역시 **가상 주소 공간**에서 동작합니다.
    - 사용자 프로세스와 달리, **사용자 영역은 없고 커널 영역만 존재**합니다.


- 커널 쓰레드도 페이지 테이블과 MMU를 통해 가상 주소를 사용한다.
- palloc이 반환하는 주소도 가상 주소이다.




### 1. 세그먼트 레지스터와 현대 OS의 메모리 관리


- **세그먼트 레지스터의 역할**
  - x86에서 코드, 데이터, 스택 등 메모리 영역 분할
  - 세그먼트의 시작 주소(베이스) + 오프셋 = 논리 주소
  - AGU(주소 생성 유닛)가 논리 주소 계산, MMU가 물리 주소 변환

- **현대 OS에서의 사용**
  - 페이징 기반 가상 메모리 관리가 주류
  - 세그먼트 레지스터는 기본값(베이스 0, 최대 크기)으로 설정
  - 특별한 경우(TLS, 시스템 콜 등)만 다르게 사용
  - 커널/유저 모드 모두에서 세그먼트 레지스터의 역할 최소화

- **교육용 OS(Pintos)에서의 사용**
  - x86 보호모드에서 동작
  - 세그먼트 레지스터는 초기 설정 후 거의 변하지 않음
  - 실제 메모리 접근은 페이징으로 처리




### 2. 커널/스레드 관리, 인터럽트, 커널 가상 주소 공간


- **커널 모드 활성화 조건**

    - 유저 프로세스가 시스템 콜 호출 시
    - 커널 쓰레드 실행 시
    - 인터럽트 핸들러 실행 시



- **인터럽트 핸들러 실행 방식**

    - CPU가 현재 실행 중인 스레드의 커널 스택을 사용
    - 커널 스레드가 직접 실행되는 것이 아님
    - 인터럽트 발생 시 CPU가 커널 모드로 전환, 커널 영역에 저장된 해당 인터럽트의 핸들러 실행



- **커널 가상 주소 공간 구조**

    - 모든 프로세스와 커널 쓰레드가 공통으로 사용하는 단일 영역
    - 유저 프로세스의 가상 주소 공간 상단에 커널 영역이 매핑됨
    - 실제로는 동일한 커널 메모리 공간을 가리킴
    - 유저 모드에서는 접근 불가, 커널 모드에서만 접근 가능



- **스레드/프로세스 정보 관리**

    - 각 스레드마다 TCB(스레드 제어 블록) 또는 PCB(프로세스 제어 블록) 구조체 사용
    - 저장 정보: 상태, 레지스터 값, 커널 스택 포인터, 스케줄링 정보 등
    - PCB/TCB는 스택 자료구조를 직접 사용하는 것이 아니라, 커널 스택의 위치(포인터)만 저장



- **PCB/TCB 관리 방식**

    - 점프테이블이 아니라 리스트, 큐, 트리 등 자료구조로 관리
    - 스케줄러가 자료구조를 통해 TCB를 색인하고 실행할 스레드 선택

    > [!nt] Pintos의 스레드/커널 스택 관리
    >
    > - thread 구조체(TCB 역할)를 링크드 리스트로 관리
    > - 각 스레드마다 4KB 페이지 할당
    >     - 페이지 하단: thread 구조체
    >     - 페이지 상단: 커널 스택 (상단→하단 방향 성장)




#### 1. 커널 쓰레드의 스택과 커널 세그먼트(코드/데이터/BSS/힙) 관계

- **커널 쓰레드마다 자신만의 커널 스택이 있다**  
  → 맞습니다! 각 쓰레드는 독립적인 스택(보통 한 페이지)을 가집니다.

- **텍스트(코드), 데이터, BSS, 힙 영역은 어떻게 되는가?**
    - **이 영역들은 모든 커널 쓰레드가 공유합니다.**
    - 즉, 커널의 코드, 전역 변수, 상수, 힙 등은  
      **커널 전체에서 하나만 존재**하며, 모든 커널 쓰레드가 동일한 영역을 사용합니다.
    - 쓰레드마다 **별도의 페이지(스택+TCB)**만 따로 할당됩니다.

##### 그림으로 표현하면:

```
[커널 가상 주소 공간]
|-------------------------|  <-- 높은 주소
|   커널 코드(텍스트)     |  <-- 모든 쓰레드가 공유
|   커널 데이터/상수      |  <-- 모든 쓰레드가 공유
|   커널 BSS              |  <-- 모든 쓰레드가 공유
|   커널 힙               |  <-- 모든 쓰레드가 공유
|-------------------------|
|   커널 쓰레드 스택+TCB  |  <-- 각 쓰레드마다 별도 페이지
|   커널 쓰레드 스택+TCB  |  <-- 각 쓰레드마다 별도 페이지
|-------------------------|  <-- 낮은 주소
```
- **요약:**  
  커널 코드/데이터/BSS/힙은 모든 커널 쓰레드가 공유  
  커널 스택+TCB는 각 쓰레드마다 별도 페이지에 위치




### `thread_create()`은 정확히 뭘하는 놈이냐?


- File Path: threads/thread.c, 215:218
  ```c
  tid_t thread_create(const char* name,
                      int priority,
                      thread_func* function,
                      void* aux)
  ```


_(일단 이 함수는 커널 쓰레드가 실행한다.)_

- 쓰레드 구조체를 담을 페이지를 0으로 채워서 할당받는다.

  ```c
  struct thread* t;

  t = palloc_get_page(PAL_ZERO);
  ```


- 쓰레드 구조체를 초기화한다. 
  ```c
      init_thread(t, name, priority);
  ```

    - 상태, 이름, rsp등 각종 멤버의 초기값을 세팅한다.
    - rsp를 세팅할 때 스택 끝 주소 8 bytes만큼 비워둔다.

      왜냐면?
        - x86-64 ABI(호환 규칙)에서는 **스택 포인터가 16바이트 단위로 정렬**되어야 합니다.
        - **스택 오버런 감지, 디버깅, 혹은 마법값(guard value) 저장** 등에 쓰일 수 있습니다.

    - thread 주조체의 trap_frame 멤버의 rip멤버에 `kernel_thread` 함수를 넣어준다.
        - 이 함수는 thread_function을 auxiliary인자와 함께 실행한다.
          _실행이 완료되면,_ 
          - 유저 프로그램의 경우 `process_exit()`도 실행한다.
          - 이후 쓰레드를 종료하고 `schedule()`을 호출한다.


- BLOCKED 상태로 초기화된 쓰레드를 `unblock()`하고, 최종적으로 `yield()` 및 `schedule()`이 실행되게 한다.

- schdule()은 아래 두가지를 수행한다.

    - `process_activate(next);`

        - `pml4_activate(next->pml4);`
          `next->pml4`를 **PDBR**(page dir base **register**)에 복사. 커널 쓰레드라면 base_pml4를 사용한다.

        - `tss_update(next);`
          인터럽트, 시스템콜 발생에 대비해 tss->rsp0을 업데이트 해둔다.
          exeception 핸들러가 유저스택을 사용할 수는 없으니까 TCB의 최상단을 사용하도록 하는것.

    - `thread_launch(next);`

        - 






> [!nt]  쓰레드 구조체 안에 struct intr_frame tf;
>
> - File Path: include/threads/thread.h, 65:65
>   ```cpp
>       struct intr_frame tf; /* Information for switching */
>   ```
> 
>   `tf`는 **trap frame**의 약자입니다.
>   
>   - **trap frame**은 CPU가 인터럽트, 예외, 시스템 콜 등으로 컨텍스트 스위칭을 할 때  
>     **레지스터와 상태 정보를 저장하는 구조체**를 의미합니다.
>
>   - Pintos에서는 `struct intr_frame`이 trap frame 역할을 하며,  
>     스레드가 실행 중 인터럽트가 발생하거나 스케줄링될 때  
>     해당 스레드의 레지스터 값, 스택 포인터, 플래그 등을 저장합니다.



### 왜 page table이 아니고 page directory냐?


**페이지 테이블이 너무 많기 때문이다.**

  - 프로세스마다 **페이지 디렉토리**가 하나씩 있습니다.
  - 페이지 디렉토리의 각 엔트리는 **페이지 테이블**을 가리킵니다.
  - CR3에는 **페이지 디렉토리의 주소**가 들어갑니다.

  - 32비트의 페이지 디렉토리 구조

    ```
    [CR3] --> [Page Directory] --> [Page Table] --> [Physical Page]
    ```


  - 64비트의 페이지 디릭토리 구조

    ```
    [CR3] --> [PML4] --> [PDPT] --> [Page Directory] --> [Page Table] --> [Physical Page]
    ```

      - PML4: 9비트 (엔트리 512개)
      - PDPT: 9비트 (엔트리 512개)
      - Page Directory: 9비트 (엔트리 512개)
      - Page Table: 9비트 (엔트리 512개)
      - Offset: 12비트 (4KB 페이지 크기)



#### 왜 페이지 테이블이 많아야 할까?


1. **가상 주소 공간을 효율적으로 관리하기 위해**
    - x86(32비트)에서 가상 주소는 4GB(2³²)입니다.
    - 한 페이지는 4KB(2¹²)입니다.
    - 4GB / 4KB = **약 100만 개의 페이지**가 필요합니다.

2. **메모리 낭비를 줄이기 위해**
    - 만약 모든 페이지를 하나의 테이블에 담으려면, 100만 개의 엔트리가 필요합니다.
    - 대부분의 프로세스는 전체 가상 주소 공간을 다 쓰지 않습니다.
    - **2단계 구조**를 쓰면, 실제로 필요한 페이지만 페이지 테이블을 만들어서 메모리 낭비를 줄일 수 있습니다.

3. **확장성과 관리의 용이성**
    - 페이지 디렉토리(1024개 엔트리) → 각 엔트리가 페이지 테이블(1024개 엔트리)을 가리킴.
    - 각 페이지 테이블은 4MB(1024 × 4KB)를 관리.
    - 전체적으로 1024 × 4MB = 4GB를 커버.

4. **페이징의 장점**
    - 메모리를 작은 단위(페이지)로 나눠서, 필요한 부분만 물리 메모리에 올릴 수 있음.
    - 프로세스마다 독립적인 가상 주소 공간을 제공.




#### pintos의 관련 함수.


- control register 또는 PDBR(page directory base register)에 pml4값을 넣어주고있다.
- pml4란 64비트 프로세서에서 주로사용하는 페이징 시스템의 최상위 페이지 디렉토리의 주소를 카리킨다.

```c
/* Store the physical address of the page directory into CR3
   aka PDBR (page directory base register).  This activates our
   new page tables immediately.  See [IA32-v2a] "MOV--Move
   to/from Control Registers" and [IA32-v3a] 3.7.5 "Base Address
   of the Page Directory". */
__attribute__((always_inline)) static __inline void lcr3(uint64_t val) {
    __asm __volatile("movq %0, %%cr3" : : "r"(val));
}
```



