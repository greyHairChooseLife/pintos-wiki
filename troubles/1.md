> [!lg] Log 2025-11-26
>
> 
> - gitbook에 나온대로 실행만 했는데 바로 에러 발생
> 
> - 여기까진 정상실행
>     `4853b72  Sat Nov 15 02:32 fix: wait_list에 넣을 때 FIFO 반영 <sangyeon kim>`
> 
> - 여기부터 에러 발생
>     `5a709c5  Sat Nov 15 02:32 feat: priority-sema <sangyeon kim>`

## 에러 로그


```sh
# root@sy-x390:/workspace/userprog/build# pintos --fs-disk=10 -p tests/userprog/args-single:args-single -- -q -f run 'args-single onearg'

Kernel PANIC at ../../threads/mmu.c:220 in pml4_activate(): assertion `is_kernel_vaddr(pml4 ? pml4 : base_pml4)' failed.
Call stack: 0x8004218f4c 0x800420d428 0x800421cd5e 0x8004207ed0 0x8004207d63 0x8004207574 0x800420a330 0x800420aaf7 0x8004207ff4 0x8004206b85 0x8004206070.
The `backtrace' program can make call stacks useful.
Read "Backtraces" in the "Debugging Tools" chapter
of the Pintos documentation for more information.
Timer: 0 ticks
Thread: 0 idle ticks, 0 kernel ticks, 0 user ticks
Console: 565 characters output
Keyboard: 0 keys pressed
Exception: 0 page faults
Powering off...
root@sy-x390:/workspace/userprog/build# backtrace 0x8004218f4c 0x800420d428 0x800421cd5e 0x8004207ed0 0x8004207d63 0x8004207574 0x800420a330 0x800420aaf7 0x8004207ff4 0x8004206b85 0x8004206070
0x0000008004218f4c: debug_panic (lib/kernel/debug.c:35)
0x000000800420d428: pml4_activate (threads/mmu.c:220)
0x000000800421cd5e: process_activate (userprog/process.c:237)
0x0000008004207ed0: schedule (threads/thread.c:642)
0x0000008004207d63: do_schedule (threads/thread.c:622)
0x0000008004207574: thread_yield (threads/thread.c:349)
0x000000800420a330: sema_up (threads/synch.c:120)
0x000000800420aaf7: lock_release (threads/synch.c:294)
0x0000008004207ff4: allocate_tid (threads/thread.c:672)
0x0000008004206b85: thread_init (threads/thread.c:116)
0x0000008004206070: main (threads/init.c:81)
```



## 해결 시도

- 어떤 변경사항으로 문제가 되었는지 확인하고 제거 해 본다.

- backtrace 보고 쫓는다.

- 쫓아간 함수들 구현의 모순을 찾는다.


### 해결

- File Path: ntos/7team/.git/log/2/commit_log, 1:17
  ```git
  commit 943dae3fbc644c77c5ffff3517d63f5012110136
  Author: sangyeon kim <greyhairchooselife@gmail.com>
  Date:   Wed Nov 26 08:43:41 2025 +0900
  
      fix: sema_up을 한다해서 무조건 yield하는게 아니다.
      
      아래 두 조건을 모두 만족하여야 한다.
      
      - sema_up을 함으로써 반응하여 깨어난 쓰레드가 있는 경우
      - 그때 깨어난 sema가 현재 쓰레드보다 우선순위가 높은 경우
      
      패착은 sema_up을 하는 존재는 항상 semaphore을 가져다 받치는 쓰레드라고
      편협하게 생각한 것이다.
  
   threads/synch.c  |  8 ++++++--
   threads/thread.c | 10 ++++++++++
   2 files changed, 16 insertions(+), 2 deletions(-)
  ```


#### AS IS


- File Path: ntos/7team/.git/992b17508a3/threads/synch.c, 107:120
  ```c
  void sema_up(struct semaphore* sema) {
      enum intr_level old_level;
  
      ASSERT(sema != NULL);
  
      old_level = intr_disable();
      if (!list_empty(&sema->waiters))
          thread_unblock(
              list_entry(list_pop_front(&sema->waiters), struct thread, elem));
  
      sema->value++;
      intr_set_level(old_level);
      thread_yield();
  }
  ```



- File Path: ntos/7team/.git/992b17508a3/threads/thread.c, 285:295
  ```c
  void thread_unblock(struct thread* t) {
      enum intr_level old_level;
  
      ASSERT(is_thread(t));
  
      old_level = intr_disable();
      ASSERT(t->status == THREAD_BLOCKED);
      list_insert_ordered(&ready_list, &t->elem, high_priority_first, NULL);
      t->status = THREAD_READY;
      intr_set_level(old_level);
  }
  ```


#### TO BE


- File Path: ntos/7team/.git/943dae3fbc6/threads/synch.c, 107:124
  ```c
  void sema_up(struct semaphore* sema) {
      enum intr_level old_level;
  
      ASSERT(sema != NULL);
  
      old_level = intr_disable();
  
      sema->value++;  // 자원은 항상 반납
  
      if (!list_empty(&sema->waiters))
      {
          // thread_unblock 내부에서 필요 시 스케줄링 알아서 된다.
          thread_unblock(
              list_entry(list_pop_front(&sema->waiters), struct thread, elem));
      }
  
      intr_set_level(old_level);
  }
  ```


- File Path: ntos/7team/.git/943dae3fbc6/threads/thread.c, 285:305
  ```c
  void thread_unblock(struct thread* t) {
      enum intr_level old_level;
  
      ASSERT(is_thread(t));
  
      old_level = intr_disable();
      ASSERT(t->status == THREAD_BLOCKED);
      list_insert_ordered(&ready_list, &t->elem, high_priority_first, NULL);
      t->status = THREAD_READY;
  
      // 새로 깨어난 t의 우선순위가 현재 스레드보다 높은지 확인
      if (thread_current() != idle_thread &&
          t->priority > thread_current()->priority)
      {
          if (intr_context())
              intr_yield_on_return();  // 인터럽트가 끝나면 스케줄링
          else
              thread_yield();
      }
      intr_set_level(old_level);
  }
  ```


